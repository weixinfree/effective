#! /usr/bin/env python3
from typing import Callable, Any, List, Iterable, Union
from functools import wraps, partial
from itertools import islice
import unittest
import re

MISMATCH = object()


class _State:
    index: int
    src: str
    size: int

    @staticmethod
    def of(s):
        if isinstance(s, _State):
            return s
        assert isinstance(s, str)
        return _State(s)

    def __init__(self, src):
        self.src = src
        self.size = len(src)
        self.index = 0

    def advance(self, step):
        self.index += step

    def __getitem__(self, item):
        if isinstance(item, slice):
            start = self.index + (item.start or 0)
            stop = self.index + (item.stop or self.size)
            return self.src[start:stop:item.step]
        elif isinstance(item, int):
            return self.src[self.index + item]
        else:
            raise SystemExit("")


class ParseC:
    def __init__(self, f, name: str = None):

        self.name = name if name else f.__name__
        self.parse_func = f
        self.auto_skip_space = True

    def map(self, f):
        self.map_func = f
        return self

    def auto_skip_space(self, skip: bool = True):
        self.auto_skip_space = skip
        return self

    def skip(self, parser):
        self.skip_parser = parser
        return self

    def parse(self, s):
        s = _State.of(s)
        r = self.parse_func(s)
        if r == MISMATCH:
            raise MismatchException(f'{self.name}', s)
        if hasattr(self, "map_func"):
            r = self.map_func(r)
        if self.auto_skip_space:
            _regex_match(r"\s*", s)
        if hasattr(self, "skip_parser"):
            self.skip_parser(s)
        return r

    def __call__(self, s):
        return self.parse(s)


class MismatchException(BaseException):
    def __init__(self, description: str, s: _State):
        super().__init__(f'mismatch {description}, at: {s.index}')


def lex(chars: str):
    def p(state: _State):
        if state[:len(chars)] == chars:
            state.advance(len(chars))
            return chars
        return MISMATCH
    return ParseC(p, "lex")


def _regex_match(pat, state):
    m = re.match(pat, state[:])
    if m:
        start, stop = m.span()
        assert start == 0
        state.advance(stop)
        return m.group()
    return MISMATCH


def regex(pat: str, name: str = "regex"):
    p = partial(_regex_match, pat)
    return ParseC(p, name)


def eof():
    def p(state: _State):
        return "EOF" if state.index == state.size else MISMATCH
    return ParseC(p, "eof")


def integer():
    return regex(r"[+-]?\d+", "integer").map(int)


def float_():
    return regex(r'[+-]?\d+(\.\d+)?', "float").map(float)


def alpha():
    return regex(r'[a-zA-Z]', "alpha")


def word():
    return regex(r'\w+', "word")


def space():
    return regex(r'\s*', "space")


def single_quoted_str():
    return quoted_str(quote="'", name="single_quoted_str")


def double_quoted_str():
    return quoted_str(quote='"', name="double_quoted_str")


def tribble_quoted_str():
    return quoted_str(quote='```', name="tribble_quoted_str")


def quoted_str(quote: str = "'", name: str = "quoted_str"):
    def p(state: _State):
        quote_len = len(quote)
        if state[:quote_len] != quote:
            return MISMATCH
        state.advance(quote_len)
        start = state.index
        while not (state[:quote_len] == quote and state[-1] != '\\'):
            state.advance(1)
        end = state.index
        state.advance(quote_len)
        return state.src[start: end]
    return ParseC(p, name)


################### combine #################

def _optional_match(parser, state: _State):
    index = state.index
    try:
        return parser(state)
    except MismatchException as e:
        state.index = index
        return None


def sepby(body_parser, sep_parser):
    def p(state: _State):
        r = []
        r.append(body_parser(state))
        while _optional_match(sep_parser, state):
            r.append(body_parser(state))
        return r
    return ParseC(p, "sepby")


def optional(parser):
    return ParseC(partial(_optional_match, parser), "optional")


def or_(*parsers):
    def p(state: _State):
        index = state.index
        for p in parsers:
            try:
                return p(state)
            except MismatchException as e:
                state.index = index

        return MISMATCH

    return ParseC(p, "any_")


def many1(parser):
    return many(parser, min_occur=1)


def many(parser, min_occur=0):
    def p(state: _State):
        r = []
        for _ in range(min_occur):
            r.append(parser(state))
        while True:
            try:
                r.append(parser(state))
            except MismatchException as e:
                break
        return r
    return ParseC(p, f'many({min_occur}-{max_occur})')

############### Test ###################


class Test(unittest.TestCase):

    def test_lex(self):
        s = _State.of("hello world")
        self.assertEqual(lex("hello")(s), "hello")
        self.assertEqual(s.index, 6)
        self.assertEqual(lex("world")(s), "world")
        self.assertEqual(s.index, 11)

    def test_regex(self):
        s = _State.of("aaaa bbbb")
        self.assertEqual(regex(r"a{4}")(s), "aaaa")
        self.assertEqual(s.index, 5)
        self.assertEqual(regex(r'b+')(s), "bbbb")
        self.assertEqual(s.index, 9)

    def test_integer(self):
        s = _State.of("123abc")
        self.assertEqual(integer()(s), 123)
        self.assertEqual(s.index, 3)
        s2 = _State.of("-123abc")
        self.assertEqual(integer()(s2), -123)
        self.assertEqual(s2.index, 4)

    def test_float(self):
        s = _State.of("123abc")
        self.assertEqual(float_()(s), 123.0)
        self.assertEqual(s.index, 3)
        s2 = _State.of("123.456")
        self.assertEqual(float_()(s2), 123.456)
        self.assertEqual(s2.index, 7)
        s3 = _State.of("-123.456")
        self.assertEqual(float_()(s3), -123.456)

    def test_quoted_str(self):
        s = _State.of('''"hello world"''')
        self.assertEqual(double_quoted_str()(s), "hello world")
        self.assertEqual(s.index, 13)

        s2 = _State.of("""'hello world'""")
        self.assertEqual(single_quoted_str()(s2), "hello world")
        self.assertEqual(s2.index, 13)

    def test_word(self):
        pass

    def test_alpha(self):
        pass

    def test_eof(self):
        pass

    def test_skip_parser(self):
        pass

    def test_skip_space(self):
        pass

    def test_map(self):
        pass

    def test_many(self):
        pass

    def test_javastr(self):
        pass

    def test_pystr(self):
        pass

    def tes_or(self):
        pass

    def test_optional(self):
        pass

    def test_many(self):
        pass


if __name__ == '__main__':
    unittest.main()
